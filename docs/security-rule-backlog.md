# Security Rule Backlog

This backlog consolidates security-focused rule ideas for Rust-cola compiled from public advisories and vu85. **Unchecked index arithmetic panic** *(shipped — RUSTCOLA080)* – Surface integer arithmetic that feeds slice/array indexing without proving the offset fits the container, mirroring MirChecker's runtime panic detections. Detects untrusted input (stdin, env vars, CLI args, file contents) flowing to array/slice index operations without bounds validation. Safe patterns recognized: `.get()` method, `.len()` comparisons, `.min()` clamping, explicit bounds checks (Lt/Le/Gt/Ge comparisons), assertions with len. **Test suite:** 11 vulnerable functions, 8 safe functions. **Metrics:** ~55% recall (6/11 detected), 100% precision (0/8 false positives). Known limitation: limited taint propagation through env::var and file reads (stdin-based input has better coverage). **Signal:** MIR dataflow – tracks untrusted input sources through parse/unwrap operations to Index trait calls. **Feasibility:** MIR dataflow.n87. **Division by unchecked denominator** *(shipped — RUSTCOLA077)* – Detects division and modulo operations where the denominator comes from untrusted sources (command-line args, environment variables, file contents, network data) without validation guards. Division by zero causes panics; division by small values can cause integer overflow. **Signal:** MIR dataflow – tracks untrusted sources to Div/Rem operations. **Feasibility:** MIR dataflow.rability pattern documentation published by various security research teams and tools. Each entry captures the rationale, the primary analysis signal we expect to leverage, and a rough feasibility tier.

## Advisory Coverage Follow-ups (Oct 2025)

Feasibility legend:

- **Heuristic** – String or signature matching with minimal context.
- **MIR dataflow** – Requires MIR-aware taint tracking or control/data-flow reasoning.
- **Advanced** – Demands deeper semantic modelling (lifetimes, aliasing, interprocedural analysis) or significant new infrastructure.

## Memory Safety & Unsafe Usage

1. **Box::into_raw escape** *(shipped)* – Detect raw pointer escapes via `Box::into_raw`. **Feasibility:** Heuristic.
2. **std::mem::transmute usage** *(shipped)* – Flag calls to `std::mem::transmute`. **Feasibility:** Heuristic.
3. **Vec::set_len misuse** *(shipped — RUSTCOLA038)* – Identify `Vec::set_len` when the vector is not fully initialized. **Feasibility:** MIR dataflow.
4. **MaybeUninit::assume_init before initialization** *(shipped — RUSTCOLA078)* – Detects `MaybeUninit::assume_init()` and `assume_init_read()` calls where the MaybeUninit value has not been initialized via `write()`, `as_mut_ptr()` writes, or safe constructors like `new()` or `zeroed()`. Reading uninitialized memory is undefined behavior. **Signal:** MIR dataflow – tracks MaybeUninit::uninit() allocations and detects assume_init/assume_init_read without preceding initialization. **Feasibility:** MIR dataflow.
5. **mem::uninitialized / mem::zeroed** *(shipped — RUSTCOLA010)* – Flag usage of deprecated zero-init APIs on non-zero types. **Feasibility:** Heuristic.
6. **Dangling pointer use-after-free** – Ensure no access after `drop` or reallocation. **Feasibility:** Advanced.
7. **Access of invalid pointer** – Catch derefs of null or misaligned pointers. **Feasibility:** Advanced.
8. **Unsafe Send/Sync impls** *(RUSTCOLA015 shipped for missing generic bounds; Tier 3 Send/Sync detection complete)* – Highlight `unsafe impl Send/Sync` without safety commentary. RUSTCOLA015 detects missing generic bounds on unsafe Send/Sync impls. Tier 3 Phase 3 adds Send/Sync trait detection via rustc's trait solver, populating `is_send`/`is_sync` fields in HirTypeMetadata for concrete types. Generic types return `null` (indeterminate without substitution). **Feasibility:** Heuristic (RUSTCOLA015) + Semantic (Tier 3 trait solver).
9. **static mut globals** *(shipped — RUSTCOLA025)* – Warn about mutable statics that break thread safety. **Feasibility:** Heuristic.
10. **NonNull::new_unchecked misuse** *(shipped — RUSTCOLA026)* – Ensure null checks before `new_unchecked`. **Feasibility:** Heuristic.
11. **mem::forget on guards** *(shipped — RUSTCOLA027)* – Catch forgetting RAII guards that release locks/resources. **Feasibility:** MIR dataflow.
12. **repr(packed) field references** *(shipped — RUSTCOLA035)* – Avoid taking references to packed struct fields. **Feasibility:** Heuristic.
13. **slice::from_raw_parts length inflation** – Validate slice length when constructed from raw pointers. **Feasibility:** Advanced.
14. **ptr::copy overlap** – Ensure non-overlapping regions for `copy_nonoverlapping`. **Feasibility:** Advanced.
15. **Unsafe FFI pointer returns** *(shipped — RUSTCOLA073)* – Require invariants when `extern "C"` returns raw pointers. **Feasibility:** Heuristic.
16. **Null pointer transmutes** *(shipped — RUSTCOLA063)* – Detects transmutation of null pointers or zero values to references and function pointers, which causes undefined behavior. Provides Public security rule guidance). **Detection patterns:** (1) transmute(const 0) or transmute(0_usize), (2) transmute(std::ptr::null()) or transmute(std::ptr::null_mut()), (3) any transmute involving 'null' keyword. Filters out internal compiler (Transmute) cast operations to reduce false positives. **Test suite:** 14 functions (7 problematic covering null→ref/mut ref/fn pointer, 7 safe covering legitimate transmutes and proper null handling). **Signal:** Heuristic – pattern matching in MIR for transmute calls with null/zero arguments. **Feasibility:** Heuristic.
17. **Raw pointer to slice of different element size** – Detect mismatched slice casts. **Feasibility:** MIR dataflow.
18. **Pointer arithmetic on zero-sized types** *(shipped — RUSTCOLA064)* – Detects pointer arithmetic operations (offset, add, sub, wrapping_offset, wrapping_add, wrapping_sub, offset_from) on zero-sized types like unit type (), PhantomData, empty structs/enums. Pointer arithmetic on ZSTs causes undefined behavior because offset calculations assume stride of size_of::<T>() which is 0 for ZSTs, violating pointer aliasing rules and provenance. Provides Public security rule guidance). **Test suite:** 14 functions (7 problematic, 7 safe). **Detection:** 5/7 problematic detected (unit type and PhantomData), 2/7 missed (custom empty struct/enum without type size info). Zero false positives on safe cases. **Signal:** Heuristic – pattern matching in MIR for pointer arithmetic methods on unit type `*const ()` or `*mut ()` and PhantomData types. **Feasibility:** Heuristic.

## Secrets & Cryptography

19. **Insecure hashing MD5/SHA-1** *(shipped)* – Detect use of MD5/SHA-1. **Feasibility:** Heuristic.
20. **Weak ciphers (DES/RC4/etc.)** *(shipped — RUSTCOLA045)* – Pattern match legacy crypto crate usage including DES, 3DES, RC4, RC2, Blowfish, CAST5, and ARCFOUR. **Feasibility:** Heuristic.
21. **Hard-coded cryptographic values** *(shipped — RUSTCOLA039)* – Spot embedded keys or IVs. **Feasibility:** MIR dataflow.
22. **Predictable randomness** *(shipped — RUSTCOLA046)* – Detects constant seeds in RNG initialization (seed_from_u64, from_seed) with context-aware severity for cryptographic functions. **Feasibility:** Heuristic.
23. **Modulo bias on random outputs** *(shipped — RUSTCOLA066)* – Detects modulo operations (%) applied to random number generator outputs in cryptographic contexts. Modulo creates non-uniform distributions that can be exploited in key generation, nonce creation, ECDSA signature schemes (k-value attacks), and token generation. **Detection:** Checks for crypto-related function names (key, token, auth, sign, encrypt, hash, nonce, salt, secret, password, session) combined with random number generation (::gen, random::, threadrng, rng) and modulo operations (Rem, %, _rem). **Test suite:** 14 functions (7 problematic using modulo in crypto contexts, 7 safe using proper techniques or non-crypto contexts). **Signal:** Heuristic – pattern matching in MIR for crypto context + random + modulo. **Metrics:** 100% recall (7/7 detected), 100% precision (0/7 false positives). **Safe alternatives:** gen_range(), fill_bytes(), rejection sampling. **Feasibility:** Heuristic.
24. **Danger accept invalid certs** *(shipped — RUSTCOLA012)* – Detects calls enabling reqwest's danger_accept_invalid_certs(true) or rustls dangerous configurations that disable certificate validation. **Feasibility:** Heuristic.
25. **OpenSSL VerifyNone** *(shipped)* – Detect `set_verify(VerifyNone)`. **Feasibility:** Heuristic.
26. **Non-HTTPS URLs** *(shipped — RUSTCOLA011)* – Detects HTTP URL literals in network-related code where HTTPS should be used. **Feasibility:** Heuristic.
27. **TLS verification disabled in custom clients** – Extend detection beyond reqwest (e.g., hyper). **Feasibility:** MIR dataflow.
28. **Weak hashing beyond MD5/SHA-1** *(shipped — RUSTCOLA062)* – Detects usage of weak or deprecated cryptographic hash algorithms beyond MD5/SHA-1, including RIPEMD family (RIPEMD-128, RIPEMD-160, RIPEMD-256, RIPEMD-320), CRC family (CRC16, CRC32, CRC32Fast, CRC64), and Adler32 checksums. These algorithms should not be used for security-sensitive operations like password hashing, authentication tokens, or cryptographic signatures. **Test suite:** 15 functions (8 problematic, 7 safe) covering RIPEMD/CRC/Adler usages and secure alternatives. **Signal:** Heuristic – pattern matching in MIR for type names and function calls. **Metrics:** 100% recall (8/8 detected), 89% precision (1/7 FP on error message string containing hash names). **Feasibility:** Heuristic.
29. **Cleartext env var exposure** *(shipped — RUSTCOLA065)* – Detects env::set_var() calls with sensitive variable names (PASSWORD, SECRET, TOKEN, API_KEY, AUTH_TOKEN, DB_PASSWORD, PRIVATE_KEY, JWT_SECRET, etc.). Environment variables are visible via /proc on Linux, process inspection tools, child processes, and system logs. Sensitive data should use secure credential storage (e.g., keyrings, secret management services) instead. **Test suite:** 15 functions (8 problematic, 7 safe) covering various sensitive variable patterns. **Signal:** Heuristic – pattern matching in MIR for set_var calls with sensitive keywords in function body. **Note:** In MIR, env::set_var appears as just 'set_var' without namespace qualification. **Metrics:** 100% recall (8/8 detected), 100% precision (0/7 false positives). **Feasibility:** Heuristic.

## Data Exposure & Logging

30. **Cleartext logging of secrets** *(shipped — RUSTCOLA075)* – Detects sensitive data (passwords, API keys, tokens, secrets) from environment variables flowing into logging macros (log, tracing, println!, eprintln!). **Signal:** MIR dataflow – tracks env::var() calls with sensitive variable names to log macro sinks. **Test results:** 86% recall (6/7 detected), 67% precision. **Feasibility:** MIR dataflow.
31. **Cleartext storage in databases** – Detect inserts of sensitive data without encryption. **Feasibility:** Advanced.
32. **Cleartext transmission** – Identify writes of sensitive data to non-TLS channels. **Feasibility:** Advanced.
33. **Log injection** *(shipped — RUSTCOLA076)* – Detects untrusted input (command-line args, environment variables, file contents, network data) flowing into logging macros without sanitization. Log injection can enable log spoofing, log forging attacks, and CRLF injection. **Signal:** MIR dataflow – tracks untrusted sources to log sinks. **Feasibility:** MIR dataflow.
34. **Hard-coded home directory paths** *(shipped — RUSTCOLA014)* – Detects absolute paths to user home directories hard-coded in string literals. Hard-coded home paths reduce portability and create security issues: code breaks when run under different users or in containers/CI, exposes username information, prevents proper multi-user deployments, and makes code non-portable across operating systems. Detects Unix/Linux (/home/username), macOS (/Users/username), Windows (C:\Users\username or C:/Users/username), and tilde with username (~username but not ~/path) patterns. Recommends using environment variables (HOME, USERPROFILE), std::env::home_dir(), or the dirs crate. **Test suite:** 17 functions (7 problematic covering all major OS path patterns, 10 safe covering environment variables, relative paths, system paths, and proper user directory access). **Signal:** Heuristic – pattern matching in MIR for home directory string literals. **Metrics:** 100% recall (7/7 detected), 100% precision (0/10 false positives). **Feasibility:** Heuristic.
35. **Invisible Unicode characters** *(shipped — RUSTCOLA048)* – Detects invisible or control Unicode characters (zero-width, bidirectional overrides, private use areas) that could enable Trojan Source attacks (CVE-2021-42574, CVE-2021-42694) or identifier spoofing. Note: Rust's compiler provides first-line defense by rejecting most invisible Unicode in identifiers (Public security rule guidance). **Feasibility:** Heuristic.

## Input Validation & Injection

36. **SQL injection** – Track untrusted input to `diesel::sql_query` and raw SQL builders. **Feasibility:** Advanced.
37. **Path traversal** – Detect tainted paths passed to filesystem APIs. **Feasibility:** Advanced.
38. **Regular expression injection** *(shipped — RUSTCOLA079)* – Detects untrusted input (env vars, CLI args, file contents) flowing to Regex::new(), RegexBuilder::new(), or RegexSet::new() without sanitization. Attackers can craft malicious patterns causing ReDoS (catastrophic backtracking) or unexpected matches. Use regex::escape() for literal matching or validate patterns against an allowlist. **Signal:** MIR dataflow – tracks untrusted sources to regex construction sinks. **Test results:** 80% recall (8/10 detected), 100% precision (0/8 false positives). **Feasibility:** MIR dataflow.
39. **Server-side request forgery** – Taint external URLs used in HTTP clients. **Feasibility:** Advanced.
40. **Command injection (process::Command)** *(shipped)* – Track execution of external commands. **Feasibility:** Heuristic.
41. **Command argument taint** *(shipped — RUSTCOLA006, deepened with dataflow)* – Ensure user input (env vars, network, files) passed to `Command::arg` is sanitized. Tracks taint from env::var/env::var_os to Command::arg, fs::write, fs::remove_file. Phase 1 complete: 52% FP reduction (95% → 43%). Phase 2 pending: sanitization detection. **Feasibility:** MIR dataflow.
42. **YAML deserialization of untrusted data** – Guard `serde_yaml::from_*`. **Feasibility:** Advanced.
43. **TOML/JSON deserialization** – Similar to YAML for other formats. **Feasibility:** Advanced.
44. **bincode / postcard deserialization** – Highlight binary format parsing on tainted input. **Feasibility:** Advanced.
45. **Regex denial-of-service** – Flag untrusted patterns compiled with catastrophic backtracking. **Feasibility:** Advanced.
46. **Template injection in web responses** – Taint tracking into response body builders. **Feasibility:** Advanced.

## Concurrency & Async

47. **Non-thread-safe calls in tests** *(shipped — RUSTCOLA074)* – Parity for external lint on `#[test]` using non-`Send` APIs. **Feasibility:** Heuristic.
48. **Unsafe `Send` across async boundaries** – Detect `Send` requirements violated in futures. **Feasibility:** Advanced.
49. **Await while holding span guard** – Avoid locking instrumentation across `.await`. **Feasibility:** Advanced.
50. **Mutex guard dropped prematurely** – Public security rule guidance
51. **panic! inside Drop** *(shipped — RUSTCOLA040)* – Prevent unwinding in destructors. **Feasibility:** Heuristic.
52. **unwrap in Drop/Poll** *(shipped — RUSTCOLA041)* – Avoid `unwrap()` in critical lifecycle methods, particularly Future::poll implementations that can stall async executors. **Feasibility:** Heuristic.
53. **Await missing in async return** – Public security rule guidance

## Resource Management & DoS

54. **Uncontrolled allocation size** – Taint to `Vec::with_capacity` etc. **Feasibility:** Advanced.
55. **Unbounded read_to_end** – Detect reading arbitrary streams into memory. **Feasibility:** Advanced.
56. **I/O buffers not fully processed** – Public security rule guidance
57. **Lines from stdin not trimmed** *(shipped — RUSTCOLA053)* – Detects stdin().lines() without .trim(), which can enable injection attacks via trailing newlines/whitespace. Heuristic-based detection (checks for stdin + lines without trim in function body). Known limitation: 50% false positive rate on test suite due to simple pattern matching rather than dataflow analysis. Public security rule guidance
58. **Infinite iterators without termination** *(shipped — RUSTCOLA054)* – Detects infinite iterators (std::iter::repeat, cycle, repeat_with) without termination methods (take, take_while, any, find, position), which can cause DoS through unbounded loops. Heuristic pattern matching in MIR. Test results: 75% recall (3/4 problematic detected), 14% FP rate (1/7 safe functions flagged). Known limitation: cannot detect manual break statements in loops. Public security rule guidance

## Configuration & Platform Issues

59. **Unix permissions not octal** *(shipped — RUSTCOLA055)* – Detects Unix file permissions specified using decimal literals instead of octal notation (e.g., 644 instead of 0o644). Decimal values like 755 look like octal but are interpreted as decimal (755 decimal = 0o1363 octal), resulting in incorrect permissions. Checks permission APIs (from_mode, chmod, DirBuilder) for common decimal values. Test results: 100% precision and recall (4/4 problematic detected, 0/6 false positives). Public security rule guidance
60. **OpenOptions inconsistent flags** *(shipped — RUSTCOLA056)* – Detects OpenOptions with dangerous or inconsistent flag combinations: (1) create() without write()/append() is useless, (2) truncate() without write()/append() causes data loss, (3) append() with truncate() is contradictory. Heuristic pattern matching for builder method combinations. Test results: 100% precision and recall (4/4 problematic detected, 0/6 false positives). Public security rule guidance
61. **File operations on tainted paths** – Strengthen path traversal detection (#37). **Feasibility:** Advanced.
62. **env::var literals in code** *(shipped — RUSTCOLA047)* – Detects string literals passed to env::var() and env::var_os(), encouraging use of constants for maintainability and typo prevention (external lint parity). **Feasibility:** Heuristic.
63. **crate-wide allow attributes** *(shipped — RUSTCOLA049)* – Detects crate-level #![allow(...)] attributes that disable lints for entire crates, reducing security coverage. Encourages targeted item-level #[allow(...)] instead (external lint parity). **Feasibility:** Heuristic.

## Web & Framework Specific

64. **warp filters leaking request body** – Ensure request body not logged verbatim. **Feasibility:** Advanced.
65. **actix-web responses with interpolated input** – Taint to HTML body formatting. **Feasibility:** Advanced.
66. **Axum extractors without validation** – Flag `Form`/`Json` usage without explicit validation. **Feasibility:** Advanced.

## Testing & Infrastructure Hygiene

67. **Commented out code** *(RUSTCOLA067 shipped)* – Detects commented-out code blocks (functions, structs, variable declarations, etc.) that should be removed to maintain clean, analyzable codebases. Commented-out code creates maintenance burden and confuses readers about actual functionality. **Pattern:** Identifies 2+ consecutive comment lines containing code-like patterns (keywords: `pub fn`, `let`, `struct`, `impl`, `use`, `match`; or patterns like assignments with `=`, semicolons, braces). Excludes doc comments (`///`, `//!`), TODO/FIXME/NOTE markers, URLs, decorative lines, and prose. **Test results:** 88% recall (7/8 detected), 100% precision (0/8 false positives). **Signal:** Source-level heuristic scanning comment lines for code patterns. **Severity:** Low. **Feasibility:** Heuristic (source-level).
68. **Dead stores in arrays** *(RUSTCOLA068 shipped)* – Detects array elements written but immediately overwritten without being read, indicating logic errors or wasted computation. Most useful for security-sensitive contexts where stale data (e.g., partial password clears) could leak. **Pattern:** Consecutive array assignments to same resolved index (e.g., `arr[0] = 10; arr[0] = 20;`) where first write is never read. Uses constant folding to resolve index variables (e.g., `_2 = const 0_usize; arr[_2] = ...`). **Test results:** 57% recall (4/7 problematic), 100% precision (0 false positives). Catches obvious consecutive-overwrite cases; complex patterns (loops, unread stores) require dataflow analysis. **Severity:** Low. **Feasibility:** Heuristic.
69. **Non-local effect before panic in tests** – Variation of . **Feasibility:** Advanced.
70. **Misordered assert_eq arguments** *(RUSTCOLA050 shipped)* – ; detects assert_eq!(literal, variable) which creates backwards error messages. Convention is assert_eq!(actual, expected). **Signal:** Promoted constants in first position of assert_failed calls. **Feasibility:** Heuristic.
71. **Try operator on io::Result** *(RUSTCOLA051 shipped)* – ; detects use of ? operator on std::io::Result without error context. **Signal:** Functions returning Result<T, io::Error> with discriminant checks (? desugaring). Recommends .map_err() or custom error types. **Feasibility:** Heuristic.
72. **Overscoped allow attributes** *(RUSTCOLA072 shipped)* – Detects crate-level `#![allow(...)]` attributes that suppress security-relevant lints across the entire crate. Broad suppression can hide security issues that should be addressed. Flags inner attributes (with `!`) for security-relevant lints: `warnings`, `unsafe_code`, `unused_must_use`, `dead_code`, `deprecated`, `non_snake_case`, `non_camel_case_types`, Clippy security-focused checks (`clippy::all`, `clippy::pedantic`, `clippy::restriction`, `clippy::unwrap_used`, `clippy::expect_used`, `clippy::panic`, `clippy::indexing_slicing`, `clippy::mem_forget`, `clippy::cast_ptr_alignment`, `clippy::integer_arithmetic`). Does NOT flag outer attributes (`#[allow(...)]`) on modules, functions, or items, which provide appropriate scoping. **Implementation:** Source-level analysis using syn crate to parse inner attributes (`#![allow(...)]`) and check lint names against security-relevant list. **Test suite:** examples/overscoped-allow with 6 problematic patterns (crate-wide suppressions) and 3 safe patterns (module-level, function-level, item-level allows). **Metrics:** 100% recall (6/6 detected), 100% precision (0/3 false positives). **Signal:** Source-level analysis. **Feasibility:** Source-level analysis (Tier 2).
73. **Local RefCell usage** *(RUSTCOLA052 shipped)* – ; detects RefCell used for purely local mutable state. **Signal:** RefCell::new() + borrow/borrow_mut in same function without shared ownership patterns. Recommends plain mut variables. **Feasibility:** Heuristic.
74. **Unnecessary borrow_mut** *(shipped — RUSTCOLA057)* – Detects RefCell::borrow_mut() calls where borrow() would suffice (no actual mutation). Using borrow_mut() for read-only access adds overhead, increases panic risk, and obscures intent. Heuristic checks for absence of mutation patterns (push, clear, sort, etc.). Test results: 25% recall (1/4 problematic detected), 100% precision (0/6 false positives). Known limitation: conservative heuristic catches simple cases only, complex MIR patterns not fully tracked. external lint parity. **Feasibility:** Heuristic.
75. **Non-thread-safe call in async context** – Extend external lint to async tasks. **Feasibility:** Advanced.

## External Tool Findings – Clippy

76. **OpenOptions missing truncate** *(RUSTCOLA032 shipped)* – Lift Clippy `suspicious_open_options`; prevent stale file contents when creating writable files without `truncate(true)` or `append(true)`. **Signal:** Builder chains on `std::fs::OpenOptions` that set `write(true)` and `create(true)` but never set truncate/append. **Feasibility:** Heuristic.
77. **Command argument concatenation** *(shipped — RUSTCOLA031)* – Detects Command::new or Command::arg calls using format!, concat!, or string concatenation which can enable command injection. **Signal:** Command construction with formatting or concatenation operators. **Feasibility:** Heuristic.
78. **Underscore-assigned lock guard** *(shipped — RUSTCOLA030)* – Detects lock guards (Mutex::lock, RwLock::read/write, etc.) assigned to `_` which immediately drops the guard. **Signal:** Pattern bindings like `let _ = mutex.lock()` for locking APIs. **Feasibility:** Heuristic.
79. **Absolute component in join** *(shipped — RUSTCOLA058)* – Detects Path::join() or PathBuf::push() receiving absolute paths which replace the base path entirely, enabling path traversal. Checks for absolute path patterns (starting with /, /home, /etc, /usr, etc.). Test results: 100% precision and recall on Unix (4/4 problematic detected, 0/6 false positives). Known limitation: Windows absolute paths require Windows compilation. Clippy `join_absolute_paths` parity. **Feasibility:** Heuristic (MIR pattern matching).
80. **set_readonly(false) permission downgrade** *(shipped — RUSTCOLA028)* – Clippy `permissions_set_readonly_false`; surface calls making files world-writable on Unix. **Signal:** Direct invocation of `std::fs::Permissions::set_readonly(false)`. **Feasibility:** Heuristic.
81. **Spawned child without wait** *(shipped — RUSTCOLA067)* – Clippy `zombie_processes` parity; detects child processes spawned via Command::spawn() that are not waited on via wait(), status(), or wait_with_output(). Failing to wait creates zombie processes that consume system resources (PIDs, kernel memory for process table entries) until the parent exits. Particularly problematic in long-running services. **Detection:** Heuristic check for Command::spawn() without corresponding wait methods in same function. **Test suite:** 15 functions (7 problematic, 8 safe). **Metrics:** 86% recall (6/7 detected), 100% precision (0/8 false positives). **Known limitation:** Misses mixed cases where some spawns are waited on but others aren't (would require per-Child value tracking). **Signal:** Track Command::spawn results to verify subsequent wait()/status() call. **Feasibility:** Heuristic.

## External Tool Findings – Rudra

82. **Unsafe closure panic guard** – Flag unsafe routines that duplicate ownership via `ptr::read`/`copy_nonoverlapping` and then invoke user-supplied closures or trait callbacks without shielding against panics (Rudra’s panic-safety bug class). **Signal:** In an `unsafe` block, raw pointer reads followed by a call to a higher-order argument without surrounding `catch_unwind` or restoring ownership before the call. **Feasibility:** Advanced.
83. **Borrow contract invariant** – Detect higher-order code that assumes repeated trait method calls (e.g., `Borrow::borrow`, `Deref::deref`) return the same reference and cache raw pointers across calls, risking aliasing bugs (Rudra higher-order invariant). **Signal:** MIR dataflow proving a pointer derived from a trait object is stored and reused after an intervening call that may mutate the source. **Feasibility:** Advanced.
84. **Generic Send/Sync bounds** *(RUSTCOLA015 shipped; duplicate of entry #8)* – Highlight `unsafe impl Send/Sync for Foo<T>` that omit trait bounds ensuring `T: Send`/`T: Sync`, echoing Rudra’s Send/Sync variance findings. **Signal:** Pattern match on unsafe impl blocks where generic parameters appear without the matching auto-trait constraint. **Feasibility:** Heuristic.

## External Tool Findings – MirChecker

85. **Unchecked index arithmetic panic** – Surface integer arithmetic that feeds slice/array indexing without proving the offset fits the container, mirroring MirChecker’s runtime panic detections. **Signal:** MIR range analysis spotting `len - offset`, `offset + start`, or scaled loop counters used as indices absent dominating `<=` guards. **Feasibility:** MIR dataflow.
86. **Unsafe deallocation of borrowed storage** – Catch lifetime-corruption patterns where unsafe code drops or frees memory reachable through active borrows (MirChecker lifetime corruption bugs). **Signal:** Track raw pointers derived from references that flow into `free`, `drop_in_place`, or manual RAII teardown before the borrow scope ends. **Feasibility:** Advanced.
87. **Division by unchecked denominator** – Warn when arithmetic divisions/modulos consume untrusted or data-dependent denominators without checked zero guards, preventing MirChecker’s reported panic class. **Signal:** Identify denominators sourced from inputs or arithmetic expressions lacking preceding `!= 0` / `checked_div` validation. **Feasibility:** MIR dataflow.

## External Tool Findings – FFIChecker

88. **FFI buffer leak on early return** – Ensure FFI marshalling code that allocates heap buffers (e.g., `Vec::with_capacity`, `Box::into_raw`) installs defer-style cleanup when `?` propagation can short-circuit before freeing (FFIChecker memory-corruption findings). **Signal:** In `extern`/FFI helpers, detect manual allocation whose pointer escapes while `?`-based error paths exit prior to cleanup. **Feasibility:** MIR dataflow.
89. **FFI panic-safe drop guard** – Flag unsafe FFI stubs that leave partially initialised buffers or state inconsistent if a Rust panic unwinds across the boundary, echoing FFIChecker's exception-safety bugs. **Signal:** Look for `unsafe` blocks preparing raw structures without `Drop` guards or `catch_unwind` before invoking external code that may unwind. **Feasibility:** Advanced.
90. **Allocator mismatch across FFI** *(shipped — RUSTCOLA033)* – Prevent mixing Rust allocators with `libc::free`/foreign deallocators on pointers created by `Box`/`CString`, matching FFIChecker's mixed-allocation UB class. **Signal:** Detect raw pointers produced by Rust allocation APIs later freed via non-matching deallocators (or vice versa). **Feasibility:** Heuristic.


## External Tool Findings – Cargo Audit

91. **RustSec unsound dependency** *(shipped — RUSTCOLA018)* – Mirror `cargo audit` informational warnings by flagging dependency versions listed in the RustSec DB as `informational = "unsound"`, so consumers patch or sandbox them. **Signal:** Cross-reference `Cargo.lock` packages against curated RustSec unsound advisories and alert even when builds succeed. **Feasibility:** Heuristic.
92. **Yanked crate version in lockfile** *(shipped — RUSTCOLA019)* – Surface dependencies that `cargo audit` would mark as yanked, prompting upgrades before the registry drops them. **Signal:** Enrich lockfile analysis with crates.io index metadata (or local cache) to report yanked versions during review. **Feasibility:** Heuristic.
93. **Release binaries missing auditable metadata** *(shipped — RUSTCOLA020)* – Encourage projects shipping binaries to embed `cargo auditable` metadata so `cargo audit bin` can produce complete reports. **Signal:** Inspect release automation for `cargo auditable` integration (feature flag, build script, or CI job) and suggest adoption when missing. **Feasibility:** Heuristic. **Severity:** Informational (policy) – highlight for teams that opt into supply-chain attestation profiles while keeping it ignorable for others.

## Additional Security Patterns (Apr 2024)

94. **Cookie without `Secure` attribute** *(shipped — RUSTCOLA042)* – Surface builders from the `cookie` or framework helpers where the `secure` flag is absent or explicitly false, mirroring external security tool rule (severity 7.5). Detects `Cookie::build()` without `.secure(true)` which allows cookies to be transmitted over unencrypted HTTP connections, enabling session hijacking. **Signal:** Track cookie builder instances and ensure a call to `secure(true)`/`set_secure(true)` dominates the use site. **Feasibility:** Heuristic (source-level pattern matching).
95. **`#[ctor]`/`#[dtor]` invoking std APIs** *(shipped — RUSTCOLA059)* – Flag functions annotated with `#[ctor]` or `#[dtor]` that call into `std::` APIs before `main`, aligning with external security tool rule. Detects constructors/destructors that invoke standard library functions during program initialization or teardown, which can cause ordering issues, deadlocks, or undefined behavior. **Implementation:** Heuristic name-based detection (functions starting with `ctor_` or `dtor_` prefix) combined with MIR analysis to find `std::` API calls or `_print()` (println! desugaring). Test suite with 12 functions (5 problematic, 7 safe) achieves 100% precision and 100% recall (all problematic cases detected: println!, Mutex usage, Vec allocation, fs operations; no false positives on safe cases). **Limitation:** Only detects functions following naming convention; requires `ctor` crate usage patterns. **Signal:** Walk macro-expanded bodies for call expressions whose fully qualified path begins with `std::`. **Feasibility:** Heuristic.

## RustRover Inspectopedia Candidates

96. **Unsafe CString pointer use** *(shipped — RUSTCOLA036)* – JetBrains [Inspectopedia: Unsafe CString pointer](https://www.jetbrains.com/help/inspectopedia/RsCStringPointer.html) flags call chains like `CString::new(...).unwrap().as_ptr()` where the temporary is dropped before the pointer escapes, creating dangling references. **Signal:** Recognize `CString::new` results whose `.as_ptr()` return value is used outside the lifetime of the owning `CString` (stored, returned, or passed onward) without preserving the backing allocation. **Feasibility:** Heuristic.
97. **Blocking sleep inside async** *(shipped — RUSTCOLA037)* – JetBrains [Inspectopedia: Blocking `sleep` function cannot be used in `async` context](https://www.jetbrains.com/help/inspectopedia/RsSleepInsideAsyncFunction.html) highlights `std::thread::sleep` and similar blocking calls inside async functions that can stall executors and enable denial-of-service conditions. **Signal:** Flag synchronous sleep APIs invoked within `async fn` bodies, futures, or sections awaiting completion without yielding back to the runtime. **Feasibility:** Heuristic.

## Additional Security Patterns (Oct 2025)

98. **Serde `serialize_*` length mismatch** *(shipped — RUSTCOLA081)* – Detects when the declared field/element count in serialize_struct/serialize_tuple/serialize_tuple_struct doesn't match the actual number of serialize_field/serialize_element calls. This mismatch can cause deserialization failures, data corruption, or panics in binary formats like bincode, postcard, or MessagePack that rely on precise length hints. **Detection patterns:** Extracts declared length from `serialize_struct(*, "Name", const N)` and counts `SerializeStruct>::serialize_field` / `SerializeTuple>::serialize_element` calls in the same function. Skips loop-based serialization (dynamic element counts). **Test suite:** 7 problematic patterns (struct/tuple/tuple_struct length mismatches), 8 safe patterns (correct counts, dynamic lengths, derive macro). **Metrics:** 71% recall (5/7 detected - seq/map with loops correctly skipped), 100% precision (0/8 false positives). **Signal:** MIR pattern analysis – counts serialization method calls. **Feasibility:** MIR dataflow.

## Security Rule Follow-ups (Nov 2025)

99. **Overly permissive CORS allowlist** *(shipped — RUSTCOLA043)* – Extend External security research’s `TooPermissiveCors` finding for Rust web stacks by flagging `CorsLayer::new()` / `warp::cors()` chains that end up with `allow_origin("*")`, wildcard `AllowOrigin::any()`, or regexes that effectively accept every origin. Unrestricted origins enable credential theft when browsers happily forward cookies or Authorization headers to attacker-controlled sites. External security research’s `rust-vulnerable-apps` repo demonstrates the issue in `cors/cors_003_bad_axum_tower_http/src/main.rs`, where `CorsLayer::new().allow_origin("*")` is annotated as the vulnerability hotspot and allows a malicious page to read JSON responses ([External security research rust-vulnerable-apps](public vulnerability example)). **Signal:** Heuristic – inspect CORS builder calls from `tower_http::cors`, `warp::cors`, and similar abstractions for wildcard origins or trivially bypassable pattern checks. **Feasibility:** Heuristic.

100. **Observable timing-based secret comparison** *(shipped — RUSTCOLA044)* – Implement Code’s `Observable Timing Discrepancy` rule for Rust (`CWE-208`) noted in the official rule index ([External security research Code rules table](public security documentation)). Timing leaks surface when credential checks or signature verifications return early on the first mismatching byte rather than using constant-time comparison. **Signal:** MIR dataflow – detect equality checks, `starts_with`, byte-wise loops, or guard clauses inside auth/crypto helpers that branch or return as soon as a mismatch is found on attacker-influenced data, and prefer flagging when the routine deals with secrets (naming heuristics like `token`, `secret`, `hmac`). **Feasibility:** MIR dataflow.

101. **World-writable file permission defaults** *(shipped — RUSTCOLA029)* – External security research’s Rust rule set also covers `Insecure File Permissions` for Rust (`CWE-732`) in the same security rule index ([External security research Code rules table](public security documentation)). Replicate that coverage by flagging calls that deliberately create or relax permissions to `0o77x`, such as `PermissionsExt::set_mode(0o777)`, `OpenOptionsExt::mode(0o777)`, or helper wrappers that pass world-writable flags on Unix targets. Highlight builder chains that combine `create(true)`/`write(true)` with explicit `mode` arguments granting group/other write bits. **Signal:** Heuristic – search for suspicious octal literals (`0o666`, `0o777`) or `set_readonly(false)` in proximity to file creation, and on Windows look for `SecurityDescriptor` ACLs granting `GENERIC_ALL` to `Everyone`. **Feasibility:** Heuristic.

## External security research SAST coverage follow-ups (Aug 2025)

102. **AWS S3 access without resource scoping** – Mirror External security research Engine Pack 9.6.4’s `Rust_Medium_Threat.Unrestricted_*_S3` queries by detecting AWS SDK calls that perform `list_objects`, `delete_objects`, or `put_object` against buckets where the bucket or key prefix comes directly from user input or uses wildcards like `"*"`. These operations can exfiltrate or destroy arbitrary data when exposed endpoints forward attacker-controlled paths to S3. **Signal:** MIR dataflow – taint the `bucket`, `key`, or `prefix` arguments on `aws_sdk_s3::Client` calls and flag flows that lack validation or confinement to an allowlist. **Feasibility:** MIR dataflow.
103. **Connection strings with empty or hardcoded passwords** *(shipped — RUSTCOLA060)* – External security research adds `Empty_Password_In_Connection_String` and `Hardcoded_Password_in_Connection_String` detections for Rust. We surface similar cases by flagging database or message-broker DSNs embedded in code or configuration with `password=` segments set to empty strings or literal secrets, nudging teams toward pulling credentials from secret stores. Implementation detects 6 protocols (`postgres://`, `postgresql://`, `mysql://`, `redis://`, `amqp://`, `mongodb://`) and identifies `:@` patterns (empty passwords) or `:password@` patterns (hardcoded credentials), excluding numeric passwords (likely ports) and format! macro component arrays. **Test suite:** 13 functions covering 6 problematic cases (various empty/hardcoded scenarios) and 7 safe patterns (env vars, localhost without auth, proper usage). **Signal:** Heuristic – search string literals for connection URI protocols and inspect credential segments. **Metrics:** 100% precision and 100% recall (6/6 detected, 0/7 false positives). **Feasibility:** Heuristic.
104. **Missing password field masking in web forms** *(shipped — RUSTCOLA061)* – External tool research highlights UI paths that echo secrets. For Rust web frameworks (Axum, Actix), audit templating and form builders for inputs representing passwords that render back to clients without obfuscation (e.g., `type="text"`, or displaying the submitted value in flash messages). **Signal:** Heuristic – identify HTML templates or server responses that interpolate variables tagged or named like `password`, `pass`, `token`, and ensure they’re either redacted or rendered with `type="password"`. **Feasibility:** Heuristic.

## RustSec advisory coverage follow-ups (Oct 2025)

105. **Protocol length truncation in SQL clients** *(shipped — RUSTCOLA022)* – RustSec advisories [RUSTSEC-2024-0363](https://rustsec.org/advisories/RUSTSEC-2024-0363.html) (SQLx) and [RUSTSEC-2024-0365](https://rustsec.org/advisories/RUSTSEC-2024-0365.html) show that casting request payload lengths to 32-bit integers lets >4 GiB inputs overflow PostgreSQL protocol frames and smuggle additional commands. Spot builder code that serializes protocol messages and downcasts `usize`/`u64` lengths to smaller integer widths without bounds checks, especially right before writing to network buffers. **Signal:** Heuristic – flag `as i32`/`as u32` casts or `.try_into::<u32>()` style conversions on variables named like `len`, `size`, or `payload_len`, and highlight when the narrowed value flows into serialization sinks such as `BufMut::put_*` / `write_*` helpers unless dominated by range assertions. **Feasibility:** Heuristic.
106. **Tokio broadcast with !Sync payloads** *(shipped — RUSTCOLA023)* – [RUSTSEC-2025-0023](https://rustsec.org/advisories/RUSTSEC-2025-0023.html) documents unsoundness when `tokio::sync::broadcast` clones values concurrently while only requiring `Send`. Encourage safer usage by warning when the payload type lacks an obvious `Sync` bound (e.g., channels instantiated for `Rc`, `RefCell`, or other single-thread types) or when custom broadcast wrappers forward `Send` but not `Sync` requirements. **Signal:** Heuristic – inspect `broadcast::channel` constructors (including `Sender`/`Receiver` helpers) for `!Sync` markers, propagate taint through reassignments, and report downstream `send`/`subscribe` sites that reuse the tainted handle. **Feasibility:** Heuristic.
107. **Trusting remote Content-Length for allocations** *(shipped — RUSTCOLA021)* – [RUSTSEC-2025-0015](https://rustsec.org/advisories/RUSTSEC-2025-0015.html) shows `web-push` DoS when clients preallocate buffers using untrusted `Content-Length`. Detects HTTP client code that reads `Response::content_length()` (or header lookups like `HeaderName::from_static("content-length")`, `HeaderValue::from_static`, `from_bytes(b"content-length")`, and `CONTENT_LENGTH` constants) to size `Vec::with_capacity`/`BytesMut::with_capacity`/`reserve*` without upper bounds. Requires explicit clamping (`min`, `clamp`, `saturating_sub`, `checked_sub`) or `assert!` guards to prevent unbounded allocations. **Signal:** MIR dataflow – tracks Content-Length header values through assignments, detects unguarded allocations. **Feasibility:** MIR dataflow.

## Analysis Infrastructure

108. **Add HIR extraction pipeline** – Introduce an optional HIR capture step alongside MIR so rules that require richer type/trait context, attribute inspection, or macro expansion metadata can operate without reimplementing `rustc` queries, giving us the best balance of high-level Rust semantics with manageable complexity. **Signal:** Compiler integration – invoke `rustc_interface` to materialize `TyCtxt`, persist a structured HIR snapshot, and correlate it with existing MIR artifacts. **Feasibility:** Advanced.

---

This list is a living document. As rules graduate from “backlog” into the shipping rule set, annotate them with *(shipped)* and link to the implementation.
