# Handoff Document - December 18, 2024

## Current State

We're investigating an **OOM (Out of Memory) issue** when running `cargo-cola` on large crates like `influxdb3` (1048 functions). The machine completely crashes during analysis.

## What We Did

### 1. Reverted Arbitrary Limits (v0.9.4)
Previously, arbitrary limits were added to prevent OOM, but these caused **false negatives** by skipping code paths. We reverted to permissive values:

```rust
// mir-extractor/src/lib.rs
const MAX_FUNCTIONS_FOR_INTERPROCEDURAL: usize = 10000;

// mir-extractor/src/dataflow/cfg.rs  
const MAX_PATHS: usize = 1000;
const MAX_DEPTH: usize = 50;

// mir-extractor/src/interprocedural.rs
const MAX_BLOCKS_FOR_PATH_ANALYSIS: usize = 500;
```

### 2. Added Memory Profiling
Created `mir-extractor/src/memory_profiler.rs` using the `sysinfo` crate to track memory at checkpoints. Enable with:
```bash
RUSTCOLA_MEMORY_PROFILE=1 cargo cola check
```

Checkpoints were added in:
- `RuleEngine::run()` in `mir-extractor/src/lib.rs`
- `InterproceduralAnalyzer::analyze()` in `mir-extractor/src/interprocedural.rs`

### 3. Test Results
- **Small crates work**: `influxdb3_id`, `influxdb3_authz` scan successfully
- **Large crates crash**: `influxdb3` with 1048 functions causes OOM
- **Memory profiler shows ~100-120 MB** before crash but doesn't capture the spike (happens too fast between checkpoints)

## Key Hypothesis

The **path explosion in `get_all_paths()`** is likely the culprit. This function in `mir-extractor/src/dataflow/cfg.rs` does DFS enumeration of all CFG paths, which can explode exponentially with complex control flow.

## Unanswered Question

**"How many paths per function and what is the depth of an average path?"**

This needs to be measured. Add instrumentation to `get_all_paths()` to log:
1. Number of paths returned per function
2. Average/max path length (number of blocks)
3. Which functions have the most paths

## Suggested Next Steps

1. **Add path statistics logging** to `get_all_paths()` in `cfg.rs`:
   ```rust
   // After path collection, before returning:
   if paths.len() > 100 {
       eprintln!("[PATH-STATS] Function has {} paths, avg depth: {}", 
           paths.len(), 
           paths.iter().map(|p| p.len()).sum::<usize>() / paths.len());
   }
   ```

2. **Run on influxdb3** with path stats enabled to identify which functions explode

3. **Consider alternative approaches**:
   - Lazy path iteration instead of collecting all paths upfront
   - Widening/narrowing in abstract interpretation instead of path enumeration
   - Demand-driven analysis that only explores relevant paths

## Key Files

| File | Purpose |
|------|---------|
| `mir-extractor/src/dataflow/cfg.rs` | `get_all_paths()` - DFS path enumeration |
| `mir-extractor/src/interprocedural.rs` | `InterproceduralAnalyzer` orchestrates analysis |
| `mir-extractor/src/memory_profiler.rs` | Memory tracking utilities |
| `mir-extractor/src/lib.rs` | `RuleEngine::run()` - main entry point |

## Test Command

```bash
cd /Users/peteralbert/Projects/influxdb/influxdb3
RUSTCOLA_MEMORY_PROFILE=1 cargo cola check 2>&1 | tee ~/cola-output.txt
```

## Important Context

- The user explicitly stated: **"Rust-cola needs to be thorough and not generate false negatives"**
- Arbitrary limits that skip analysis are NOT acceptable solutions
- We need to find the actual root cause and fix it properly (lazy evaluation, better algorithms, etc.)
