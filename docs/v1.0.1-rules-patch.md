# Rust-COLA v1.0.1 Rules Patch Document

**Date:** 2026-01-25  
**Status:** Proposed  
**Priority:** High  
**Affected Components:** mir-extractor, cargo-cola

---

## Overview

This document describes improvements to reduce false positives identified during analysis of real-world Rust codebases (specifically InfluxDB OSS). The v1.0.0 release produces accurate findings but generates noise in certain patterns that should be filtered or enhanced with additional context.

### Summary of Issues

| Rule | Issue | False Positive Rate | Priority |
|------|-------|---------------------|----------|
| RUSTCOLA087 | Matches SQL keywords in log messages | ~90% | P0 |
| RUSTCOLA024 | Misses HTTP-layer size guards | ~60% | P0 |
| **Test Code** | ~1,700 findings in test/example code | 100% | P0 |
| RUSTCOLA088 | Confuses file I/O with SSRF | ~80% | P1 |
| RUSTCOLA081 | Incorrect serde field counting (no dedup) | ~50% | P2 |
| LLM Prompt | No guard context in findings | N/A | P1 |
| LLM Prompt | No call chain visualization | N/A | P1 |
| LLM Prompt | No call-path verification for guards | N/A | P1 |

---

## P0: RUSTCOLA087 - SQL Injection False Positives

### Problem

The SQL injection rule matches on SQL keywords (SELECT, UPDATE, INSERT, etc.) in **any** const string, including:
- Log messages: `"Unexpected error deleting table from catalog."`
- CLI help text: `"Run the InfluxDB 3 Core server\n\nExamples..."`
- Error messages: `"failed to parse snapshot sequence number from filename"`

### Root Cause

The rule checks for SQL keywords in const strings but does not verify:
1. Whether an actual SQL execution sink exists in the function
2. Whether the string is used in a logging/display context

### Fix

**File:** `mir-extractor/src/rules/injection.rs`

#### 1. Add exclusion patterns for non-SQL contexts

```rust
impl SqlInjectionRule {
    // NEW: Patterns that indicate log/error/help messages, not SQL
    const NON_SQL_CONTEXTS: &'static [&'static str] = &[
        // Logging
        "error!",
        "warn!",
        "info!",
        "debug!",
        "trace!",
        "tracing::",
        "log::",
        "eprintln!",
        "println!",
        // Error handling
        "anyhow::Context",
        ".context(",
        "Error::new",
        "bail!",
        "thiserror",
        "snafu",
        // CLI/help
        "--help",
        "Usage:",
        "USAGE:",
        "[OPTIONS]",
        "[ARGS]",
        "Examples",
        "[env:",
        "[default:",
        // Database terminology in non-SQL contexts
        "catalog",
        "persist",
        "snapshot",
        "compaction",
        "partition",
    ];

    fn is_non_sql_context(&self, body: &[String], evidence_line: &str) -> bool {
        // Check if evidence line contains CLI/help patterns
        for pattern in Self::NON_SQL_CONTEXTS {
            if evidence_line.contains(pattern) {
                return true;
            }
        }
        
        // Check if function body is primarily logging/error handling
        let body_str = body.join("\n");
        let log_count = Self::NON_SQL_CONTEXTS.iter()
            .filter(|p| body_str.contains(*p))
            .count();
        
        log_count >= 2 // Multiple logging patterns = likely not SQL
    }
}
```

#### 2. Require actual SQL execution sink

```rust
impl SqlInjectionRule {
    // Actual SQL execution functions (not just string building)
    const SQL_EXECUTION_SINKS: &'static [&'static str] = &[
        "execute(",
        "query(",
        "query_as(",
        "query_one(",
        "query_row(",
        "query_map(",
        "prepare(",
        "sql_query(",
        "execute_batch(",
        "raw_query(",
        "Connection::execute",
        "Client::query",
        "sqlx::query",
        "diesel::sql_query",
        "rusqlite::execute",
        "tokio_postgres::query",
        "Statement::execute",
    ];

    fn has_sql_execution_sink(&self, body: &[String]) -> bool {
        let body_str = body.join("\n");
        Self::SQL_EXECUTION_SINKS.iter().any(|sink| body_str.contains(sink))
    }
}
```

#### 3. Modify evaluate() to apply filters

```rust
impl Rule for SqlInjectionRule {
    fn evaluate(&self, package: &MirPackage, _: Option<&InterProceduralAnalysis>) -> Vec<Finding> {
        let mut findings = Vec::new();

        for function in &package.functions {
            // NEW: Skip if no SQL execution sink exists
            if !self.has_sql_execution_sink(&function.body) {
                continue;
            }

            let untrusted_vars = self.track_untrusted_vars(&function.body);
            if self.has_sql_sanitization(&function.body) {
                continue;
            }

            let evidence = self.find_unsafe_sql_operations(&function.body, &untrusted_vars);
            
            // NEW: Skip if evidence is from non-SQL context
            if evidence.iter().all(|e| self.is_non_sql_context(&function.body, e)) {
                continue;
            }

            // ... rest of finding creation
        }

        findings
    }
}
```

### Expected Impact

- Eliminates ~40-45 false positives per large codebase
- No reduction in true positive detection (SQL sinks are still required)

### Tests to Add

```rust
#[test]
fn sql_injection_ignores_log_messages() {
    let mir = r#"
        fn log_error() {
            info!("Failed to update database table");
            error!("SELECT operation timed out");
        }
    "#;
    let findings = analyze(mir);
    assert!(findings.is_empty(), "Log messages should not trigger SQL injection");
}

#[test]
fn sql_injection_ignores_cli_help() {
    let mir = r#"
        const HELP: &str = "Usage: myapp [OPTIONS]\n\n\
            Commands:\n  update  Update database\n  delete  Delete records";
    "#;
    let findings = analyze(mir);
    assert!(findings.is_empty(), "CLI help text should not trigger SQL injection");
}

#[test]
fn sql_injection_detects_real_query() {
    let mir = r#"
        fn vulnerable(user_input: &str) {
            let query = format!("SELECT * FROM users WHERE name = '{}'", user_input);
            conn.execute(&query)?;
        }
    "#;
    let findings = analyze(mir);
    assert_eq!(findings.len(), 1, "Real SQL injection should be detected");
}
```

---

## P0: RUSTCOLA024 - Missed HTTP Layer Guards

### Problem

The unbounded allocation rule correctly identifies `with_capacity(input.len())` as tainted, but fails to recognize that HTTP handlers often enforce request size limits upstream (in a different crate).

Example from InfluxDB:
- `influxdb3_write` has `with_capacity(rows.len())` - flagged as unbounded
- `influxdb3_server` has `max_http_request_size` check - not recognized as guard

### Root Cause

Guard detection is function-local and doesn't propagate across crate boundaries.

### Fix

**File:** `mir-extractor/src/prototypes.rs`

#### 1. Add HTTP-layer guard patterns

```rust
impl Default for PrototypeOptions {
    fn default() -> Self {
        Self {
            guard_markers: vec![
                // Existing guards
                "::min".to_string(),
                ".min(".to_string(),
                "cmp::min".to_string(),
                "::clamp".to_string(),
                ".clamp(".to_string(),
                "::saturating_sub".to_string(),
                "::checked_sub".to_string(),
                
                // NEW: HTTP/request size guards
                "max_request_bytes".to_string(),
                "max_request_size".to_string(),
                "max_body_size".to_string(),
                "body_limit".to_string(),
                "DefaultBodyLimit".to_string(),
                "RequestBodyLimit".to_string(),
                "content_length_limit".to_string(),
                "PayloadConfig".to_string(),
                "ContentLengthLimit".to_string(),
                
                // NEW: Generic limit patterns
                "MAX_".to_string(),
                "_LIMIT".to_string(),
                "max_size".to_string(),
                "size_limit".to_string(),
            ],
            // ... rest unchanged
        }
    }
}
```

**File:** `mir-extractor/src/interprocedural.rs`

#### 2. Add cross-crate guard detection

```rust
/// HTTP layer guard information
#[derive(Debug, Clone)]
pub struct HttpGuardInfo {
    pub guard_type: HttpGuardType,
    pub crate_name: String,
    pub function: String,
    pub max_value: Option<usize>,
}

#[derive(Debug, Clone)]
pub enum HttpGuardType {
    RequestSizeLimit,
    RateLimit,
    Authentication,
    InputValidation,
}

impl InterProceduralAnalysis {
    /// Detect HTTP-layer guards that protect downstream code
    pub fn detect_http_guards(&self) -> Vec<HttpGuardInfo> {
        let mut guards = Vec::new();
        
        for (func_name, summary) in &self.summaries {
            let body_str = summary.body_text.as_deref().unwrap_or("");
            
            // Request size limit detection
            if (body_str.contains("max_request") || body_str.contains("body_limit"))
                && body_str.contains("Err(")
            {
                guards.push(HttpGuardInfo {
                    guard_type: HttpGuardType::RequestSizeLimit,
                    crate_name: summary.crate_name.clone(),
                    function: func_name.clone(),
                    max_value: Self::extract_size_limit(body_str),
                });
            }
            
            // Rate limit detection
            if body_str.contains("rate_limit") || body_str.contains("RateLimiter") {
                guards.push(HttpGuardInfo {
                    guard_type: HttpGuardType::RateLimit,
                    crate_name: summary.crate_name.clone(),
                    function: func_name.clone(),
                    max_value: None,
                });
            }
        }
        
        guards
    }
    
    fn extract_size_limit(body: &str) -> Option<usize> {
        // Pattern 1: const MAX_SIZE: usize = 10_485_760;
        // Pattern 2: max_request_bytes: 10000000
        // Pattern 3: .body_limit(10 * 1024 * 1024)
        
        use regex::Regex;
        
        // Match numeric literals near size-related keywords
        let patterns = [
            r"(?i)max_request[^0-9]*([0-9][0-9_]*)",
            r"(?i)body_limit[^0-9]*([0-9][0-9_]*)",
            r"(?i)max_size[^0-9]*([0-9][0-9_]*)",
            r"(?i)size_limit[^0-9]*([0-9][0-9_]*)",
            r"(?i)content_length[^0-9]*([0-9][0-9_]*)",
        ];
        
        for pattern in patterns {
            if let Ok(re) = Regex::new(pattern) {
                if let Some(caps) = re.captures(body) {
                    if let Some(m) = caps.get(1) {
                        let num_str = m.as_str().replace('_', "");
                        if let Ok(val) = num_str.parse::<usize>() {
                            // Sanity check: must be > 1KB and < 1TB
                            if val > 1024 && val < 1_000_000_000_000 {
                                return Some(val);
                            }
                        }
                    }
                }
            }
        }
        
        // Also check for expressions like: 10 * 1024 * 1024
        if let Ok(re) = Regex::new(r"(\d+)\s*\*\s*1024\s*\*\s*1024") {
            if let Some(caps) = re.captures(body) {
                if let Some(m) = caps.get(1) {
                    if let Ok(multiplier) = m.as_str().parse::<usize>() {
                        return Some(multiplier * 1024 * 1024);
                    }
                }
            }
        }
        
        None
    }
}
```

#### 3. Call-path verification for cross-crate guards

```rust
impl InterProceduralAnalysis {
    /// Verify that a guard is on the call path to a sink
    pub fn guard_protects_sink(
        &self,
        guard: &HttpGuardInfo,
        sink_function: &str,
    ) -> Option<CallPathEvidence> {
        // Build reverse call graph from sink back to entry points
        let call_graph = self.build_call_graph();
        
        // Find all paths from HTTP entry points to the sink
        let entry_points = self.find_http_entry_points();
        
        for entry in &entry_points {
            if let Some(path) = call_graph.find_path(entry, sink_function) {
                // Check if guard function appears on this path
                if path.iter().any(|f| f == &guard.function) {
                    return Some(CallPathEvidence {
                        entry_point: entry.clone(),
                        path_through_guard: path,
                        guard_function: guard.function.clone(),
                        sink_function: sink_function.to_string(),
                    });
                }
            }
        }
        
        None
    }
    
    fn find_http_entry_points(&self) -> Vec<String> {
        // Look for common HTTP handler patterns
        let patterns = [
            "axum::handler",
            "actix_web::web",
            "warp::Filter",
            "rocket::handler",
            "hyper::service",
            "tower::Service",
            "#[get(", "#[post(", "#[put(", "#[delete(",
        ];
        
        self.summaries.iter()
            .filter(|(_, s)| {
                let body = s.body_text.as_deref().unwrap_or("");
                patterns.iter().any(|p| body.contains(p))
            })
            .map(|(name, _)| name.clone())
            .collect()
    }
}

#[derive(Debug, Clone)]
pub struct CallPathEvidence {
    pub entry_point: String,
    pub path_through_guard: Vec<String>,
    pub guard_function: String,
    pub sink_function: String,
}
```

#### 4. Export guards with findings

```rust
// In Finding struct or as separate metadata
pub struct FindingContext {
    pub finding: Finding,
    pub upstream_guards: Vec<HttpGuardInfo>,
    pub call_chain: Option<Vec<String>>,
    pub guard_evidence: Option<CallPathEvidence>,  // NEW: Proves guard is on path
}

impl FindingContext {
    /// Returns true if at least one guard is verified to protect this sink
    pub fn is_guarded(&self) -> bool {
        self.guard_evidence.is_some()
    }
    
    /// Suggested severity adjustment based on guard analysis
    pub fn adjusted_severity(&self) -> Severity {
        if let Some(evidence) = &self.guard_evidence {
            match self.finding.severity {
                Severity::Critical => Severity::Medium,  // Guarded critical → medium
                Severity::High => Severity::Low,         // Guarded high → low
                _ => self.finding.severity,
            }
        } else {
            self.finding.severity
        }
    }
}
```

### Expected Impact

- Reduces false positives for DoS/allocation findings by ~60%
- Provides actionable context: "Protected by 10MB request limit"
- **NEW:** Proves guard-to-sink relationship with call path evidence

---

## P1: RUSTCOLA088 - SSRF False Positives on File I/O

### Problem

The SSRF rule flagged `read_plugin_code()` as SSRF because the interprocedural analysis tagged it as "sink: http", when it's actually local file reading with robust path validation.

### Root Cause

1. Generic "http" sink matching without distinguishing HTTP requests from file I/O
2. Path validation guards (`canonicalize`, `starts_with`) not recognized

### Fix

**File:** `mir-extractor/src/rules/injection.rs` (or `web.rs`)

```rust
impl SsrfRule {
    // File I/O operations that are NOT SSRF
    const FILE_IO_PATTERNS: &'static [&'static str] = &[
        "fs::read",
        "fs::write",
        "fs::read_to_string",
        "fs::read_dir",
        "File::open",
        "File::create",
        "std::fs::",
        "tokio::fs::",
        "async_std::fs::",
        "canonicalize",
        "read_to_string",
        "BufReader",
        "BufWriter",
    ];

    // Actual HTTP request sinks
    const HTTP_REQUEST_SINKS: &'static [&'static str] = &[
        "reqwest::get",
        "reqwest::Client",
        "reqwest::Request",
        "hyper::Client",
        "hyper::Request",
        "surf::get",
        "surf::post",
        "ureq::get",
        "ureq::post",
        "HttpClient::request",
        "http::Request::builder",
        "Client::get(",
        "Client::post(",
        ".fetch(",
        "isahc::get",
        "attohttpc::get",
    ];

    // Path validation guards that prevent SSRF-like attacks
    const PATH_GUARDS: &'static [&'static str] = &[
        "canonicalize",
        "starts_with",
        "strip_prefix",
        "is_absolute",
        "Component::ParentDir",
        "PathTraversal",
        "validate_path",
        "check_path",
    ];

    fn is_file_io_not_http(&self, function: &MirFunction) -> bool {
        let body_str = function.body.join("\n");
        
        let has_file_io = Self::FILE_IO_PATTERNS.iter()
            .any(|p| body_str.contains(p));
        let has_http = Self::HTTP_REQUEST_SINKS.iter()
            .any(|p| body_str.contains(p));
        
        has_file_io && !has_http
    }

    fn has_path_validation(&self, function: &MirFunction) -> bool {
        let body_str = function.body.join("\n");
        Self::PATH_GUARDS.iter().any(|p| body_str.contains(p))
    }
}

impl Rule for SsrfRule {
    fn evaluate(&self, package: &MirPackage, _: Option<&InterProceduralAnalysis>) -> Vec<Finding> {
        for function in &package.functions {
            // NEW: Skip file I/O operations
            if self.is_file_io_not_http(function) {
                continue;
            }
            
            // NEW: Skip if path validation exists
            if self.has_path_validation(function) {
                // Could emit a lower-severity "review path validation" finding instead
                continue;
            }
            
            // ... rest of SSRF detection
        }
    }
}
```

### Expected Impact

- Eliminates file I/O false positives
- Still detects actual SSRF where HTTP clients are used

---

## P1: LLM Prompt Generation - Add Guard Context

### Problem

The LLM prompt instructs the AI to look for guard functions, but doesn't provide the guard analysis results from the static analyzer. The LLM must re-analyze code that was already analyzed.

### Fix

**File:** `cargo-cola/src/main.rs`

#### 1. Add guard context to finding output

```rust
fn write_finding_detail_with_guards(
    content: &mut String,
    index: usize,
    finding: &Finding,
    rules: &[RuleMetadata],
    guards: &[HttpGuardInfo],  // NEW parameter
) -> Result<()> {
    // ... existing finding output ...

    // NEW: Add guard analysis section
    let relevant_guards: Vec<_> = guards.iter()
        .filter(|g| g.protects_sink(&finding.function))
        .collect();
    
    if !relevant_guards.is_empty() {
        writeln!(content, "**Upstream Guards Detected:**")?;
        for guard in &relevant_guards {
            writeln!(content, "- `{}::{}` ({:?})", 
                guard.crate_name, guard.function, guard.guard_type)?;
            if let Some(max) = guard.max_value {
                writeln!(content, "  - Limit: {} bytes", max)?;
            }
        }
        writeln!(content)?;
        writeln!(content, "⚠️ **Analyzer Note:** Upstream guards detected. \
            Verify these guards are on the code path to this sink.")?;
        writeln!(content)?;
    }

    Ok(())
}
```

#### 2. Add guard analysis section to prompt template

```rust
fn write_guard_analysis_instructions(content: &mut String) -> Result<()> {
    writeln!(content, "### Step 2.5: Guard Function Verification")?;
    writeln!(content)?;
    writeln!(content, "The static analyzer has detected potential guard functions. \
        For each finding, check if guards protect the vulnerable sink.")?;
    writeln!(content)?;
    writeln!(content, "| Guard Type | Patterns to Look For | Effect |")?;
    writeln!(content, "|------------|----------------------|--------|")?;
    writeln!(content, "| **Size Limit** | `max_request_size`, `body_limit`, `ContentLength` | Bounds allocation size |")?;
    writeln!(content, "| **Input Validation** | `validate_`, `is_valid_`, `check_`, `verify_` | Rejects bad input |")?;
    writeln!(content, "| **Path Guard** | `canonicalize`, `starts_with`, `PathTraversal` | Prevents path traversal |")?;
    writeln!(content, "| **Auth Guard** | `authenticate`, `authorize`, `require_auth` | Limits to authed users |")?;
    writeln!(content, "| **Rate Limit** | `RateLimiter`, `rate_limit`, `throttle` | Limits request frequency |")?;
    writeln!(content)?;
    writeln!(content, "**If a guard protects the sink:**")?;
    writeln!(content, "- For size limits: Downgrade DoS severity, note the limit value")?;
    writeln!(content, "- For input validation: Check if validation is complete, may still be partial bypass")?;
    writeln!(content, "- For path guards: Verify canonicalization + prefix check, dismiss if complete")?;
    writeln!(content)?;

    Ok(())
}
```

#### 3. Add call chain visualization to findings

```rust
// In build_llm_prompt_content, after writing finding details:

fn write_call_chain(
    content: &mut String,
    finding: &Finding,
    call_graph: &CallGraph,
) -> Result<()> {
    if let Some(chain) = call_graph.trace_to_entry_point(&finding.function) {
        writeln!(content, "**Call Chain from Entry Point:**")?;
        writeln!(content, "```")?;
        
        for (i, step) in chain.iter().enumerate() {
            let indent = "  ".repeat(i);
            let marker = if step.is_guard { " ✓ GUARD" } else { "" };
            
            if i == 0 {
                writeln!(content, "Entry: {} ({})", step.function, step.entry_type)?;
            } else if i == chain.len() - 1 {
                writeln!(content, "{}→ {} ← SINK", indent, step.function)?;
            } else {
                writeln!(content, "{}→ {}{}", indent, step.function, marker)?;
            }
        }
        
        writeln!(content, "```")?;
        writeln!(content)?;
    }
    
    Ok(())
}
```

---

## P2: RUSTCOLA081 - Serde Field Count Fix

### Problem

The serde mismatch rule occasionally miscounts fields in custom `Serialize` implementations due to:
1. Double-counting when the same field is referenced multiple times in MIR
2. Not extracting field names for deduplication
3. Counting conditional serialization as multiple fields

### Root Cause Analysis

In the InfluxDB false positive, `WriteLineError` was flagged as "declares 3, serializes 6" but manual inspection showed 3 unique fields. The MIR contains multiple references to the same `serialize_field` call due to:
- Error handling paths (each `?` creates a branch)
- Trait method resolution showing the same call multiple ways

### Fix

**File:** `mir-extractor/src/rules/code_quality.rs` (or relevant file)

```rust
use std::collections::HashSet;
use regex::Regex;

fn count_serialized_fields(function: &MirFunction) -> (Option<usize>, usize) {
    let mut declared = None;
    let mut seen_fields: HashSet<String> = HashSet::new();
    
    for line in &function.body {
        // Extract declared count from serialize_struct call
        if line.contains("serialize_struct") {
            // Pattern: serialize_struct("Name", const N_usize)
            if let Some(count) = extract_const_usize(line) {
                declared = Some(count);
            }
        }
        
        // Extract field name and deduplicate
        if line.contains("serialize_field") {
            if let Some(field_name) = extract_field_name(line) {
                seen_fields.insert(field_name);
            }
        }
    }
    
    (declared, seen_fields.len())
}

fn extract_const_usize(line: &str) -> Option<usize> {
    // Look for pattern: const N_usize where N is a number
    let re = Regex::new(r"const\s+(\d+)_usize").ok()?;
    re.captures(line)?.get(1)?.as_str().parse().ok()
}

fn extract_field_name(line: &str) -> Option<String> {
    // Pattern 1: serialize_field("field_name", ...)
    // Pattern 2: const "field_name" in the same line
    let patterns = [
        r#"serialize_field\s*\(\s*"([^"]+)""#,
        r#"const\s+"([^"]+)"\s*,"#,
        r#"\"([a-z_][a-z0-9_]*)\"\s*,\s*&?self"#i,
    ];
    
    for pattern in patterns {
        if let Ok(re) = Regex::new(pattern) {
            if let Some(caps) = re.captures(line) {
                if let Some(m) = caps.get(1) {
                    return Some(m.as_str().to_string());
                }
            }
        }
    }
    
    None
}

impl Rule for SerdeLengthMismatchRule {
    fn evaluate(&self, package: &MirPackage, _: Option<&InterProceduralAnalysis>) -> Vec<Finding> {
        let mut findings = Vec::new();
        
        for function in &package.functions {
            // Only check Serialize implementations
            if !function.name.contains("serialize") {
                continue;
            }
            
            let (declared, unique_fields) = count_serialized_fields(function);
            
            if let Some(decl) = declared {
                // Allow small variance (±1) to account for optional fields
                let diff = (decl as i64 - unique_fields as i64).abs();
                
                if diff <= 1 {
                    continue; // Within tolerance, likely correct
                }
                
                // Significant mismatch - emit finding
                findings.push(Finding {
                    rule_id: "RUSTCOLA081".to_string(),
                    severity: Severity::Medium,  // Downgraded from High
                    message: format!(
                        "Serde serialize_struct declares {} fields but found {} unique field names",
                        decl, unique_fields
                    ),
                    evidence: format!(
                        "Declared: {}, Unique fields found: {}, Difference: {}",
                        decl, unique_fields, diff
                    ),
                    // ...
                });
            }
        }
        
        findings
    }
}
```

### Test Cases

```rust
#[test]
fn serde_correct_count_not_flagged() {
    // This should NOT trigger - counts match
    let mir = r#"
        fn serialize() {
            serialize_struct("Foo", const 3_usize);
            serialize_field("a", &self.a);
            serialize_field("b", &self.b);
            serialize_field("c", &self.c);
        }
    "#;
    let findings = analyze(mir);
    assert!(findings.is_empty());
}

#[test]
fn serde_duplicate_references_deduplicated() {
    // Same field referenced multiple times (error paths) - should NOT trigger
    let mir = r#"
        fn serialize() {
            serialize_struct("Foo", const 2_usize);
            serialize_field("a", &self.a)?;  // Path 1
            serialize_field("a", &self.a);   // Path 2 (after error)
            serialize_field("b", &self.b);
        }
    "#;
    let findings = analyze(mir);
    assert!(findings.is_empty(), "Duplicate field refs should be deduplicated");
}

#[test]
fn serde_real_mismatch_detected() {
    // Actual mismatch - SHOULD trigger
    let mir = r#"
        fn serialize() {
            serialize_struct("Foo", const 2_usize);  // Says 2
            serialize_field("a", &self.a);
            serialize_field("b", &self.b);
            serialize_field("c", &self.c);
            serialize_field("d", &self.d);  // But serializes 4
        }
    "#;
    let findings = analyze(mir);
    assert_eq!(findings.len(), 1);
}
```

---

## P0: Global Test Code Exclusion

### Problem

The InfluxDB analysis produced 1,828 raw findings, of which ~1,700 were in test code. These are automatically dismissed but still consume analysis time and clutter reports.

### Fix

**File:** `cargo-cola/src/main.rs`

#### 1. Add `--exclude-tests` CLI flag

```rust
#[derive(Parser)]
struct Args {
    // ... existing args ...
    
    /// Exclude test code from analysis (files in tests/, test modules, #[cfg(test)])
    #[arg(long, default_value = "true")]
    exclude_tests: bool,
    
    /// Exclude example code from analysis
    #[arg(long, default_value = "true")]
    exclude_examples: bool,
    
    /// Exclude benchmark code from analysis  
    #[arg(long, default_value = "true")]
    exclude_benches: bool,
}
```

#### 2. Add test code detection

**File:** `mir-extractor/src/lib.rs`

```rust
impl MirFunction {
    /// Returns true if this function is test code
    pub fn is_test_code(&self) -> bool {
        // Check path patterns
        let path_patterns = [
            "/tests/",
            "/test/",
            "_test.rs",
            "_tests.rs",
            "/benches/",
            "/examples/",
        ];
        
        if path_patterns.iter().any(|p| self.file_path.contains(p)) {
            return true;
        }
        
        // Check function name patterns
        let name_patterns = [
            "::tests::",
            "::test_",
            "#[test]",
            "#[cfg(test)]",
            "::mock_",
            "::fake_",
        ];
        
        if name_patterns.iter().any(|p| self.name.contains(p)) {
            return true;
        }
        
        // Check for test attributes in body (from MIR metadata)
        if self.attributes.iter().any(|a| a.contains("test") || a.contains("cfg(test)")) {
            return true;
        }
        
        false
    }
}
```

#### 3. Filter during analysis

```rust
impl MirPackage {
    pub fn filter_production_code(&self, options: &FilterOptions) -> MirPackage {
        MirPackage {
            functions: self.functions.iter()
                .filter(|f| {
                    if options.exclude_tests && f.is_test_code() {
                        return false;
                    }
                    // ... other filters ...
                    true
                })
                .cloned()
                .collect(),
            ..self.clone()
        }
    }
}

#[derive(Default)]
pub struct FilterOptions {
    pub exclude_tests: bool,
    pub exclude_examples: bool,
    pub exclude_benches: bool,
}
```

### Expected Impact

- Reduces analysis time by ~30-50% on large codebases
- Eliminates ~1,700 test-code findings from reports
- Still allows `--exclude-tests=false` for security-focused test analysis

---

## Implementation Checklist

### Phase 1 (P0) - Target: v1.0.1

- [ ] RUSTCOLA087: Add SQL execution sink requirement
- [ ] RUSTCOLA087: Add non-SQL context filtering
- [ ] RUSTCOLA087: Add test cases for log messages and CLI help
- [ ] RUSTCOLA024: Add HTTP-layer guard patterns to `PrototypeOptions`
- [ ] RUSTCOLA024: Add test cases for guarded allocations
- [ ] **NEW:** Add `--exclude-tests` CLI flag (default: true)
- [ ] **NEW:** Add test code detection in `MirFunction::is_test_code()`
- [ ] Update CHANGELOG.md

### Phase 2 (P1) - Target: v1.0.2

- [ ] RUSTCOLA088: Distinguish file I/O from HTTP sinks
- [ ] RUSTCOLA088: Add path validation guard detection
- [ ] LLM Prompt: Add guard context to finding output
- [ ] LLM Prompt: Add "Guard Function Verification" section
- [ ] LLM Prompt: Add call chain visualization
- [ ] **NEW:** Implement `guard_protects_sink()` call-path verification
- [ ] **NEW:** Add `CallPathEvidence` to finding context

### Phase 3 (P2) - Target: v1.1.0

- [ ] Cross-crate guard propagation in interprocedural analysis
- [ ] RUSTCOLA081: Fix serde field counting with deduplication
- [ ] **NEW:** RUSTCOLA081: Add ±1 tolerance for optional fields
- [ ] **NEW:** RUSTCOLA081: Extract and compare actual field names
- [ ] Export `HttpGuardInfo` in analysis results
- [ ] Add `--show-guards` CLI flag for debugging

---

## Testing Strategy

### Regression Tests

Each fix should include:
1. **True Positive Test:** Verify real vulnerabilities still detected
2. **False Positive Test:** Verify the specific FP pattern is now filtered
3. **Edge Case Test:** Boundary conditions (partial matches, etc.)

### Integration Test: InfluxDB

Re-run analysis on InfluxDB after patches:

```bash
cargo build -p cargo-cola
./target/debug/cargo-cola --crate-path /path/to/influxdb --out-dir /tmp/influxdb-v101

# Compare finding counts (production code only)
diff <(grep -c "RUSTCOLA087" /tmp/influxdb-v100/raw-report.md) \
     <(grep -c "RUSTCOLA087" /tmp/influxdb-v101/raw-report.md)
```

**Expected Results (v1.0.1):**

| Metric | v1.0.0 | v1.0.1 | Improvement |
|--------|--------|--------|-------------|
| Total raw findings | 1,828 | ~150 | 92% reduction |
| Test code findings | ~1,700 | 0 | 100% (excluded) |
| RUSTCOLA087 (SQL injection) | 47 | <5 | ~90% |
| RUSTCOLA024 (Unbounded alloc) | 75 | <30 | ~60% (+ guard notes) |
| RUSTCOLA088 (SSRF) | 1 | 0 | 100% |
| RUSTCOLA081 (Serde mismatch) | 3 | 0 | 100% (was FP) |
| Analysis time | ~4 min | ~2.5 min | ~35% faster |

---

## References

- [InfluxDB Analysis Report](/Users/ana/projects/influxdb/out/cola/security-report.md)
- [OWASP SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection)
- [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)
- [CWE-918: Server-Side Request Forgery](https://cwe.mitre.org/data/definitions/918.html)
